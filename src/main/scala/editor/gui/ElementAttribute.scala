package editor.gui

import _root_.editor.collection.Categorization
import _root_.editor.collection.mutable.Deck
import _root_.editor.database.attributes.CantBeFiltered
import _root_.editor.database.attributes.CantCompare
import _root_.editor.database.attributes.CardAttribute
import _root_.editor.database.attributes.CombatStat
import _root_.editor.database.attributes.Expansion
import _root_.editor.database.attributes.HasMultiOptionsFilter
import _root_.editor.database.attributes.HasOptions
import _root_.editor.database.attributes.HasSingletonOptionsFilter
import _root_.editor.database.attributes.Loyalty
import _root_.editor.database.attributes.ManaCost
import _root_.editor.database.attributes.ManaType
import _root_.editor.database.attributes.Rarity
import _root_.editor.database.attributes.TypeLine
import _root_.editor.database.card.Card
import _root_.editor.database.card.CardLayout
import _root_.editor.database.symbol.ManaSymbolInstances.ColorSymbol
import _root_.editor.filter.leaf._
import _root_.editor.gui.deck.EditorFrame
import _root_.editor.gui.deck.InclusionCellEditor
import _root_.editor.gui.filter.FilterSelectorPanel
import _root_.editor.gui.filter.editor._
import _root_.editor.gui.generic.ComponentUtils
import _root_.editor.gui.generic.SpinnerCellEditor
import _root_.editor.unicode._

import java.awt.Color
import java.awt.Graphics
import java.time.LocalDate
import javax.swing.BoxLayout
import javax.swing.Icon
import javax.swing.JComponent
import javax.swing.JLabel
import javax.swing.JPanel
import javax.swing.table.TableCellEditor
import scala.reflect.ClassTag

/**
 * Acts as an extension to [[CardAttribute]] used for generating GUI elements corresponding to the attribute.
 * 
 * @tparam T data type of the attribute
 * @tparam F [[Filter]] type generated by the attribute
 * 
 * @author Alec Roelke
 */
sealed trait ElementAttribute[T : ClassTag, F <: FilterLeaf] {
  /** Attribute corresponding to the generated GUI elements. */
  def attribute: CardAttribute[T, F]

  /**
   * Create a GUI element used for editing the fields of a filter for the attribute.
   * 
   * @param selector panel containing the filter editor panel used for selecting which attribute to filter
   * @return a panel containing the elements needed to edit the filter fields
   */
  def filter(selector: FilterSelectorPanel): FilterEditorPanel[F]

  /** Create a component to render the value of a card's corresponding attribute. */
  def render(value: T): JComponent

  /** Create a string to use to render the value of a card's corresponding attribute in a tooltip for when a container isn't large enough to display the full rendering. */
  def tooltip(value: T): String

  /**
   * If the attribute can be edited in-place in a [[CardTable]], create an editor for doing that.
   * 
   * @param editor deck frame for which the editor component should be created, if there is one
   * @return a cell editor for the frame, or None if there is no frame or the value can't be edited in-place
   */
  def cellEditor(editor: Option[EditorFrame]): Option[TableCellEditor]

  /**
   * Create a component rendering a value of the corresponding attribute. Exists for compatibility with GUI elements that don't specify types of provided values.
   * 
   * @param value value to render; should be castable to the type of the attribute
   * @return a component rendering the given attribute value
   */
  final def getRendererComponent(value: AnyRef) = value match { case t: T => render(t) }

  /**
   * Create tooltip text for rendering a value of the corresponding attribute, to be used when a container isn't big enough to display the entire component.
   * Exists for compatibility with GUI elements that don't specify types of provided values.
   * 
   * @param value value to render; should be castable to the type of the attribute
   * @return a component rendering the given attribute value
   */
  final def getToolTipText(value: AnyRef) = value match { case t: T => s"<html>${tooltip(t)}</html>" }

  /** Create a cell editor for a frame, if the value can be edited */
  final def cellEditor(editor: EditorFrame): Option[TableCellEditor] = cellEditor(Some(editor))

  override def toString = attribute.toString
}

///////////////////////
// FILTER GENERATORS //
///////////////////////

/**
 * An [[ElementAttribute]] that creates [[TextFilter]]s.
 * @author Alec Roelke
 */
sealed trait TextElement { this: ElementAttribute[Seq[String], TextFilter] =>
  override def filter(selector: FilterSelectorPanel) = TextFilterPanel(attribute.filter, selector)
}

/**
 * An [[ElementAttribute]] that creates [[NumberFilter]]s.
 * @author Alec Roelke
 */
sealed trait NumberElement { this: ElementAttribute[?, NumberFilter] =>
  override def filter(selector: FilterSelectorPanel) = NumberFilterPanel(attribute.filter, selector)
}

/**
 * An [[ElementAttribute]] that creates [[ColorFilter]]s and renders [[ManaType]] sets as a row of mana type icons.
 * @author Alec Roelke
 */
sealed trait ColorElement { this: ElementAttribute[Set[ManaType], ColorFilter] =>
  override def filter(selector: FilterSelectorPanel) = ColorFilterPanel(attribute.filter, selector)
  override def render(value: Set[ManaType]) = {
    val panel = JPanel()
    panel.setLayout(BoxLayout(panel, BoxLayout.X_AXIS))
    ManaType.sorted(value).foreach((t) => panel.add(JLabel(ColorSymbol(t).scaled(ComponentUtils.TextSize))))
    panel
  }
  override def tooltip(value: Set[ManaType]) = ManaType.sorted(value).map((t) => {
    s"""<img src="${getClass.getResource(s"/images/symbols/${ColorSymbol(t).name}")}" width="${ComponentUtils.TextSize}" height="${ComponentUtils.TextSize}"/>"""
  }).mkString
}

/**
 * An [[ElementAttribute]] that creates [[SingletonOptionFilter]]s.
 * @tparam T type of data of the options in the filter
 * @author Alec Roelke
 */
sealed trait SingletonOptionsElement[T <: AnyRef : ClassTag] { this: ElementAttribute[T, SingletonOptionsFilter[T]] =>
  override def attribute: CardAttribute[T, SingletonOptionsFilter[T]] with HasSingletonOptionsFilter[T]
  override def filter(selector: FilterSelectorPanel) = OptionsFilterPanel(attribute.filter, attribute.options, selector)
}

/**
 * An [[ElementAttribute]] that creates [[MultiOptionsFilter]]s.
 * @tparam T type of data of the options in the filter
 * @author Alec Roelke
 */
sealed trait MultiOptionsElement[T <: AnyRef : ClassTag, F <: MultiOptionsFilter[T] : ClassTag] { this: ElementAttribute[Set[T], F] =>
  override def attribute: CardAttribute[Set[T], F] with HasMultiOptionsFilter[T]
  override def filter(selector: FilterSelectorPanel) = OptionsFilterPanel(attribute.filter, attribute.options, selector)
}

/////////////////////
// VALUE RENDERERS //
/////////////////////

/**
 * An [[ElementAttribute]] that renders values as strings.
 *
 * @param str function converting the value to a string
 * @tparam T type of value that is rendered
 *
 * @author Alec Roelke
 */
sealed trait SimpleStringRenderer[T](str: (T) => String = (v: T) => v.toString) { this: ElementAttribute[T, ?] =>
  override def render(value: T) = JLabel(str(value))
  override def tooltip(value: T) = str(value)
}

/**
 * An [[ElementAttribute]] that renders collections of values as strings.
 * 
 * @param toSeq function converting a (potentially unordered) collection of values to an ordered list of values
 * @param delim delimiter between values of the ordered collection
 * @param str function converting individual values to strings
 * @tparam T type of each element of the collection
 * @tparam I type of collection containing values
 * 
 * @author Alec Roelke
 */
sealed trait SimpleIterableRenderer[T, I <: Iterable[T]](toSeq: (I) => Seq[T] = (it: I) => it.toSeq, delim: String = Card.FaceSeparator, str: (T) => String = (v: T) => v.toString) {
  this: ElementAttribute[I, ?] =>

  private def getString(value: I) = toSeq(value).map(str).mkString(delim)
  override def render(value: I) = JLabel(getString(value))
  override def tooltip(value: I) = getString(value)
}

/**
 * An [[ElementAttribute]] that renders collections of optional values as strings, using the empty string if all elements are None.
 * 
 * @param toSeq function converting a (potentially unordered) collection of values to an ordered list of values
 * @param delim delimiter between values of the ordered collection
 * @param str function converting individual values to strings
 * @param T type of each element of the collection of options
 * @param I type of the collection containing optional values
 * 
 * @author Alec Roelke
 */
sealed trait OptionIterableRenderer[T, I <: Iterable[Option[T]]](toSeq: (I) => Seq[Option[T]] = (it: I) => it.toSeq, delim: String = Card.FaceSeparator, str: (T) => String = (v: T) => v.toString) {
  this: ElementAttribute[I, ?] =>

  private def getString(value: I) = if (value.flatten.isEmpty) "" else value.map(_.map(str).getOrElse("")).mkString(Card.FaceSeparator)
  override def render(value: I) = JLabel(getString(value))
  override def tooltip(value: I) = getString(value)
}

/**
 * An [[ElementAttribute]] not meant for rendering data values.
 * @author Alec Roelke
 */
sealed trait CantBeRendered[T] { this: ElementAttribute[T, ?] =>
  override def attribute: CardAttribute[T, ?] with CantCompare[T]
  override def render(value: T) = throw UnsupportedOperationException(s"$attribute can't be rendered")
  override def tooltip(value: T) = throw UnsupportedOperationException(s"$attribute can't be rendered")
}

////////////////////////
// TABLE CELL EDITORS //
////////////////////////

sealed trait CantBeEdited { this: ElementAttribute[?, ?] =>
  override def cellEditor(editor: Option[EditorFrame]) = None
}

/**
 * Companion object containing all element attributes and global data about them.
 * @author Alec Roelke
 */
object ElementAttribute {
  /** Element for filtering and renderng card names. */
  case object NameElement extends ElementAttribute[Seq[String], TextFilter] with TextElement with SimpleIterableRenderer[String, Seq[String]]() with CantBeEdited {
    override def attribute = CardAttribute.Name
  }

  /** Element for rendering card rules text. */
  case object RuleTextElement extends ElementAttribute[Seq[String], TextFilter] with TextElement with CantBeRendered[Seq[String]] with CantBeEdited {
    override def attribute = CardAttribute.RulesText
  }

  /** Element for rendering card printed text. */
  case object PrintedTextElement extends ElementAttribute[Seq[String], TextFilter] with TextElement with CantBeRendered[Seq[String]] with CantBeEdited {
    override def attribute = CardAttribute.FlavorText
  }

  /** Element for rendering and filtering card mana costs. Mana costs are rendered as sequences of [[ManaSymbol]]s as they appear on the card separated by // for multi-faced cards. */
  case object ManaCostElement extends ElementAttribute[Seq[ManaCost], ManaCostFilter] with CantBeEdited {
    private val cache = collection.mutable.Map[Seq[ManaCost], Seq[Seq[Icon]]]()

    override def attribute = CardAttribute.ManaCost
    override def filter(selector: FilterSelectorPanel) = ManaCostFilterPanel(selector)
    override def render(value: Seq[ManaCost]) = {
      val icons = cache.getOrElseUpdate(value, value.map(_.map(_.scaled(ComponentUtils.TextSize))))
      val panel = JPanel()
      panel.setLayout(BoxLayout(panel, BoxLayout.X_AXIS))
      for (i <- 0 until icons.size) {
        if (!icons(i).isEmpty) {
          if (i > 0)
            panel.add(JLabel(Card.FaceSeparator))
          icons(i).foreach((icon) => panel.add(JLabel(icon)))
        }
      }
      panel
    }
    override def tooltip(value: Seq[ManaCost]) = {
      value.map(_.map((s) => {
        s"""<img src="${getClass.getResource(s"/images/symbols/${s.name}")}" width="${ComponentUtils.TextSize}" height="${ComponentUtils.TextSize}"/>"""
      }).mkString).mkString(Card.FaceSeparator)
    }
  }

  /**
   * Element for rendering and filtering card "real" (global) mana value.
   * @see [[CardAttribute.RealManaValue]]
   */
  case object RealManaValueElement extends ElementAttribute[Double, NumberFilter] with NumberElement with CantBeEdited {
    private[ElementAttribute] def getString(value: Double) = if (value == value.toInt) value.toInt.toString else value.toString
    override def attribute = CardAttribute.RealManaValue
    override def render(value: Double) = JLabel(getString(value))
    override def tooltip(value: Double) = getString(value)
  }

  /**
   * Element for rendering and filtering card "effective" (per-face) mana value.
   * @see [[CardAttribute.EffManaValue]]
   */
  case object EffManaValueElement extends ElementAttribute[Seq[Double], NumberFilter] with NumberElement with CantBeEdited {
    override def attribute = CardAttribute.EffManaValue
    override def render(value: Seq[Double]) = JLabel(value.map(RealManaValueElement.getString).mkString(Card.FaceSeparator))
    override def tooltip(value: Seq[Double]) = value.map(RealManaValueElement.getString).mkString(Card.FaceSeparator)
  }

  /** Element filtering by and rendering card colors across all faces. */
  case object ColorsElement extends ElementAttribute[Set[ManaType], ColorFilter] with ColorElement with CantBeEdited {
    override def attribute = CardAttribute.Colors
  }

  /** Element for filtering by and rendering color identity. */
  case object ColorIdentityElement extends ElementAttribute[Set[ManaType], ColorFilter] with ColorElement with CantBeEdited {
    override def attribute = CardAttribute.ColorIdentity
  }

  /** Element for filtering by and rendering type line. */
  case object TypeLineElement extends ElementAttribute[Seq[TypeLine], TypeLineFilter] with SimpleIterableRenderer[TypeLine, Seq[TypeLine]]() with CantBeEdited {
    override def attribute = CardAttribute.TypeLine
    override def filter(selector: FilterSelectorPanel) = TypeLineFilterPanel(selector)
  }

  /** Element for filtering by and rendering printed type line. */
  case object PrintedTypesElement extends ElementAttribute[Seq[String], TextFilter]
      with TextElement
      with SimpleIterableRenderer[String, Seq[String]]()
      with CantBeEdited {
    override def attribute = CardAttribute.PrintedTypes
  }

  /** Element for filtering by and rendering card types. */
  case object CardTypeElement extends ElementAttribute[Set[String], MultiOptionsFilter[String]]
      with MultiOptionsElement[String, MultiOptionsFilter[String]]
      with SimpleIterableRenderer[String, Set[String]](_.toSeq.sorted, ", ")
      with CantBeEdited {
    override def attribute = CardAttribute.CardType
  }

  /** Element for filtering by and rendering subtypes. */
  case object SubtypeElement extends ElementAttribute[Set[String], MultiOptionsFilter[String]]
      with MultiOptionsElement[String, MultiOptionsFilter[String]]
      with SimpleIterableRenderer[String, Set[String]](_.toSeq.sorted, ", ")
      with CantBeEdited {
    override def attribute = CardAttribute.Subtype
  }

  /** Element for filtering by and rendering supertypes. */
  case object SupertypeElement extends ElementAttribute[Set[String], MultiOptionsFilter[String]]
      with MultiOptionsElement[String, MultiOptionsFilter[String]]
      with SimpleIterableRenderer[String, Set[String]](_.toSeq.sorted, ", ")
      with CantBeEdited {
    override def attribute = CardAttribute.Supertype
  }

  /** Element for filtering by and rendering creature (and Vehicle) power. */
  case object PowerElement extends ElementAttribute[Seq[Option[CombatStat]], NumberFilter]
      with NumberElement
      with OptionIterableRenderer[CombatStat, Seq[Option[CombatStat]]]()
      with CantBeEdited {
    override def attribute = CardAttribute.Power
  }

  /** Element for filtering by and rendering creature (and Vehicle) toughness. */
  case object ToughnessElement extends ElementAttribute[Seq[Option[CombatStat]], NumberFilter]
      with NumberElement
      with OptionIterableRenderer[CombatStat, Seq[Option[CombatStat]]]()
      with CantBeEdited {
    override def attribute = CardAttribute.Toughness
  }

  /** Element for filtering by and rendering planeswalker loyalty. */
  case object LoyaltyElement extends ElementAttribute[Seq[Option[Loyalty]], NumberFilter]
      with NumberElement
      with OptionIterableRenderer[Loyalty, Seq[Option[Loyalty]]]()
      with CantBeEdited {
    override def attribute = CardAttribute.Loyalty
  }

  /** Element for filtering by and rendering card layout. */
  case object LayoutElement extends ElementAttribute[CardLayout, SingletonOptionsFilter[CardLayout]]
      with SingletonOptionsElement[CardLayout]
      with SimpleStringRenderer[CardLayout]()
      with CantBeEdited {
    override def attribute = CardAttribute.Layout
  }

  /** Element for filtering by and rendering printing expansion. */
  case object ExpansionElement extends ElementAttribute[Expansion, SingletonOptionsFilter[Expansion]]
      with SingletonOptionsElement[Expansion]
      with SimpleStringRenderer[Expansion]()
      with CantBeEdited {
    override def attribute = CardAttribute.Expansion
  }

  /** Element for filtering by and rendering block containing printing expansion. */
  case object BlockElement extends ElementAttribute[String, SingletonOptionsFilter[String]]
      with SingletonOptionsElement[String]
      with SimpleStringRenderer[String]()
      with CantBeEdited {
    override def attribute = CardAttribute.Block
  }

  /** Element for filtering by and rendering printing rarity. */
  case object RarityElement extends ElementAttribute[Rarity, SingletonOptionsFilter[Rarity]]
      with SingletonOptionsElement[Rarity]
      with SimpleStringRenderer[Rarity]()
      with CantBeEdited {
    override def attribute = CardAttribute.Rarity
  }

  /** Element for filtering by and rendering printing artist. Assumes all faces of a card have the same artist. */
  case object ArtistElement extends ElementAttribute[Seq[String], TextFilter] with TextElement with CantBeEdited {
    override def attribute = CardAttribute.Artist
    override def render(value: Seq[String]) = JLabel(value(0))
    override def tooltip(value: Seq[String]) = value(0)
  }

  /** Element for filtering by and rendering collector number. */
  case object CardNumberElement extends ElementAttribute[Seq[String], NumberFilter]
      with NumberElement
      with SimpleIterableRenderer[String, Seq[String]]()
      with CantBeEdited {
    override def attribute = CardAttribute.CardNumber
  }

  /** Element for filtering by and rendering legal tournament formats. */
  case object LegalInElement extends ElementAttribute[Set[String], LegalityFilter] with SimpleIterableRenderer[String, Set[String]](_.toSeq.sorted, ", ") with CantBeEdited {
    override def attribute = CardAttribute.LegalIn
    override def filter(selector: FilterSelectorPanel) = LegalityFilterPanel(attribute.filter, selector)
  }

  /** Element for filtering by and rendering user-defined tags. Tags are sorted alphabetically for rendering. */
  case object TagsElement extends ElementAttribute[Set[String], MultiOptionsFilter[String]]
      with MultiOptionsElement[String, MultiOptionsFilter[String]]
      with SimpleIterableRenderer[String, Set[String]](_.toSeq.sorted, ", ")
      with CantBeEdited {
    override def attribute = CardAttribute.Tags
  }

  /** Element for creating "filters" that pass any card. */
  case object AnyCardElement extends ElementAttribute[Unit, BinaryFilter] with CantBeRendered[Unit] with CantBeEdited {
    override def attribute = CardAttribute.AnyCard
    override def filter(selector: FilterSelectorPanel) = BinaryFilterPanel(true)
  }

  /** Element for creating "filters" that pass no card. */
  case object NoCardElement extends ElementAttribute[Unit, BinaryFilter] with CantBeRendered[Unit] with CantBeEdited {
    override def attribute = CardAttribute.NoCard
    override def filter(selector: FilterSelectorPanel) = BinaryFilterPanel(false)
  }

  /** Element for rendering categories in decks a card belongs to. Renders them as a row of squares colored according to category color. */
  case object CategoriesElement extends ElementAttribute[Set[Categorization], Nothing] {
    override def attribute = CardAttribute.Categories
    override def filter(selector: FilterSelectorPanel) = throw UnsupportedOperationException("can't filter by category")
    override def render(value: Set[Categorization]) = {
      val categories = value.toSeq.sortBy(_.name)
      val panel = new JPanel {
        override def paintComponent(g: Graphics) = {
          super.paintComponent(g)
          for (i <- 0 until categories.size) {
            val x = i*(getHeight + 1) + 1
            val y = 1
            g.setColor(categories(i).color)
            g.fillRect(x, y, getHeight - 3, getHeight - 3)
            g.setColor(Color.BLACK)
            g.drawRect(x, y, getHeight - 3, getHeight - 3)
          }
        }
      }
      panel
    }
    override def tooltip(value: Set[Categorization]) = s"""Categories:${value.map((c) => s"<br>$Bullet ${c.name}").toSeq.sorted.mkString}"""
    override def cellEditor(editor: Option[EditorFrame]) = editor.map(InclusionCellEditor(_))
  }

  /** Element for rendering number of copies of a card in a deck. */
  case object CountElement extends ElementAttribute[Int, Nothing] with SimpleStringRenderer[Int]() {
    override def attribute = CardAttribute.Count
    override def filter(selector: FilterSelectorPanel) = throw UnsupportedOperationException("can't filter by count")
    override def cellEditor(editor: Option[EditorFrame]) = editor.map(_ => SpinnerCellEditor())
  }

  /** Element for rendering the date a card was added to a deck. Uses "month day, year" to format dates. */
  case object DateAddedElement extends ElementAttribute[LocalDate, Nothing] with CantBeEdited {
    import CardAttribute.DateAdded
    override def attribute = DateAdded
    override def filter(selector: FilterSelectorPanel) = throw UnsupportedOperationException("can't filter by date")
    override def render(value: LocalDate) = JLabel(DateAdded.format(value))
    override def tooltip(value: LocalDate) = DateAdded.format(value)
  }

  /** Array of GUI element attributes. */
  val values: IndexedSeq[ElementAttribute[?, ?]] = IndexedSeq(NameElement, RuleTextElement, PrintedTextElement, ManaCostElement, RealManaValueElement, EffManaValueElement, ColorsElement, ColorIdentityElement, TypeLineElement, PrintedTypesElement, CardTypeElement, SubtypeElement, SupertypeElement, PowerElement, ToughnessElement, LoyaltyElement, LayoutElement, ExpansionElement, BlockElement, RarityElement, ArtistElement, CardNumberElement, LegalInElement, TagsElement, AnyCardElement, NoCardElement, CategoriesElement, CountElement, DateAddedElement)

  /** Array of GUI element attributes that can create filters. */
  val filterableValues = values.filter(!_.attribute.isInstanceOf[CantBeFiltered])

  /** Get the GUI element attribute corresponding to a [[CardAttribute]], if there is one. */
  val fromAttribute = values.map((a) => a.attribute -> a).toMap
}